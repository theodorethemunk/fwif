(function(n, r) {
    typeof exports == "object" && typeof module < "u" ? module.exports = r() : typeof define == "function" && define.amd ? define(r) : (n = typeof globalThis < "u" ? globalThis : n || self, n.EhWebglSlideShow = r())
})(this, function() {
    "use strict";
    var l = Object.defineProperty;
    var d = (n, r, o) => r in n ? l(n, r, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: o
    }) : n[r] = o;
    var a = (n, r, o) => (d(n, typeof r != "symbol" ? r + "" : r, o), o);
    class n {
        constructor() {
            this.events = {}
        }
        on(t, e) {
            this.events[t] || (this.events[t] = []), this.events[t].push(e)
        }
        removeListener(t, e) {
            if (!this.events[t]) {
                console.warn(`Unable to remove listener ${e}, event with name ${t} not found`);
                return
            }
            this.events[t].filter(s => s !== e)
        }
        emit(t, e) {
            if (!this.events[t]) {
                console.warn(`Can't emit event, event with name ${t} not found`);
                return
            }
            const s = i => {
                i(e)
            };
            this.events[t].forEach(s)
        }
    }
    class r extends n {
        constructor(e) {
            super();
            a(this, "createTexture", e => {
                const s = this.gl.createTexture();
                return this.gl.bindTexture(this.gl.TEXTURE_2D, s), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, 4), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, e), this.gl.bindTexture(this.gl.TEXTURE_2D, null), s
            });
            a(this, "onResize", () => {
                this.setCanvasSize()
            });
            a(this, "destroy", () => {
                window.removeEventListener("resize", this.onResize.bind(this)), this.gl.deleteVertexArray(this.vao), this.gl.deleteProgram(this.program), this.gl = null, this.canvas = null
            });
            this.options = e, this.parent = e.parent, this.canvas = e.canvas, this.vertexSource = e.vertexSource, this.fragmentSource = e.fragmentSource, this.isExtension = e.isExtension || !1, this.dpr = Math.min(window.devicePixelRatio, 2), this.time = 0, this.uniforms = {}, this.init(), this.initEvents()
        }
        init() {
            this.setCanvasSize(), this.createContext(), this.getExtensions(), this.createShaders(), this.createProgram(), this.createVAO(), this.setBaseUniforms()
        }
        createContext() {
            this.gl = this.canvas.getContext("webgl2", {
                alpha: !0,
                antialias: !0,
                depth: !1,
                stencil: !1,
                premultipliedAlpha: !1,
                preserveDrawingBuffer: !1,
                powerPreference: "default"
            }), this.gl || console.error("Unable to create a webgl2 context"), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !0)
        }
        getExtensions() {
            this.extensions = [], this.extensions.WEBGL_lose_context = this.gl.getExtension("WEBGL_lose_context"), this.extensions.EXT_texture_filter_anisotropic = this.gl.getExtension("EXT_texture_filter_anisotropic")
        }
        createShader(e, s) {
            const i = this.gl.createShader(e);
            if (this.gl.shaderSource(i, s), this.gl.compileShader(i), this.gl.getShaderParameter(i, this.gl.COMPILE_STATUS)) return i;
            console.error(`Error compiling shader ${this.gl.getShaderInfoLog(i)}`), this.gl.deleteShader(i)
        }
        createShaders() {
            this.vertexShader = this.createShader(this.gl.VERTEX_SHADER, this.vertexSource), this.fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, this.fragmentSource)
        }
        createProgram() {
            this.program = this.gl.createProgram(), this.gl.attachShader(this.program, this.vertexShader), this.gl.attachShader(this.program, this.fragmentShader), this.gl.linkProgram(this.program), this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS) ? this.gl.useProgram(this.program) : (console.error(`Error linking Program ${this.gl.getProgramInfoLog(this.program)}`), this.gl.deleteProgram(this.program))
        }
        createQuad() {
            this.quad = {
                position: [-1, -1, 1, -1, 1, 1, -1, 1],
                positionLocation: this.gl.getAttribLocation(this.program, "position"),
                positionBuffer: this.gl.createBuffer(),
                indices: new Uint16Array([1, 2, 0, 0, 2, 3]),
                indicesBuffer: this.gl.createBuffer(),
                uv: [0, 0, 1, 0, 1, 1, 0, 1],
                uvLocation: this.gl.getAttribLocation(this.program, "uv"),
                uvBuffer: this.gl.createBuffer()
            }
        }
        createVAO() {
            this.vao = this.gl.createVertexArray(), this.gl.bindVertexArray(this.vao), this.quad || this.createQuad(), this.gl.enableVertexAttribArray(this.quad.positionLocation), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quad.positionBuffer), this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.quad.position), this.gl.STATIC_DRAW), this.gl.vertexAttribPointer(this.quad.positionLocation, 2, this.gl.FLOAT, !1, 0, 0), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.quad.indicesBuffer), this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, this.quad.indices, this.gl.STATIC_DRAW), this.gl.enableVertexAttribArray(this.quad.uvLocation), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quad.uvBuffer), this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.quad.uv), this.gl.STATIC_DRAW), this.gl.vertexAttribPointer(this.quad.uvLocation, 2, this.gl.FLOAT, !1, 0, 0)
        }
        setBaseUniforms() {
            this.addUniform(this.createUniform("uResolution", "uniform2f", [this.canvas.width, this.canvas.height])), this.addUniform(this.createUniform("uTime", "uniform1f", this.time, !0))
        }
        addUniform(e) {
            this.uniforms[e.name] = { ...e.type,
                ...e.value,
                ...e.needsUpdate,
                ...e.location
            }
        }
        createUniform(e, s, i, h) {
            const u = {};
            return u.name = e, u.type = s, u.value = i, u.needsUpdate = h || !1, u.location = this.gl.getUniformLocation(this.program, e), this.updateUniform(u), u
        }
        updateUniform(e) {
            switch (e.type) {
                case "uniform1f":
                case "uniform1i":
                    this.gl[e.type](e.location, e.value);
                    break;
                case "uniform2f":
                    this.gl[e.type](e.location, e.value[0], e.value[1]);
                    break
            }
        }
        updateUniforms() {
            for (let e in this.uniforms) this.uniforms[e].needsUpdate && this.updateUniform(this.uniforms[e])
        }
        draw() {
            this.gl.drawElements(this.gl.TRIANGLES, this.quad.indices.length, this.gl.UNSIGNED_SHORT, 0)
        }
        preUpdate() {
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height), this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT)
        }
        update() {
            this.time += 1e-4, this.uniforms.uTime.value = this.time, this.updateUniforms()
        }
        setCanvasSize() {
            this.canvas.width = this.isExtension ? window.innerWidth * this.dpr : this.parent.clientWidth * this.dpr, this.canvas.height = this.isExtension && this.parent.clientHeight > window.innerHeight ? window.innerHeight * this.dpr : this.parent.clientHeight * this.dpr, this.canvas.height == 0 && (this.canvas.height = 720 * this.dpr)
        }
        onIntersection(e, s) {
            this.shouldRender = e[0].isIntersecting, this.emit("intersection", this.shouldRender)
        }
        initIntersetionObserver() {
            const e = {
                root: null,
                rootMargin: "0px",
                threshold: .1
            };
            this.observer = new IntersectionObserver(this.onIntersection.bind(this), e), this.observer.observe(this.parent)
        }
        initEvents() {
            this.initIntersetionObserver(), window.addEventListener("resize", this.onResize.bind(this))
        }
    }
    class o {
        constructor(t) {
            a(this, "animate", () => {
                this.startTime = Date.now(), this.requestId = requestAnimationFrame(this.playTransition)
            });
            a(this, "playTransition", () => {
                let t = Date.now() - this.startTime;
                this.progress = this.outSine(t, 0, 1, this.duration), t < this.duration ? this.requestId = requestAnimationFrame(this.playTransition) : (this.progress = 0, this.currentTexture = this.textures[this.nextTextureIndex], this.nextTextureIndex == this.textures.length - 1 ? this.nextTextureIndex = 0 : this.nextTextureIndex++, this.nextTexture = this.textures[this.nextTextureIndex], this.setActiveTextures(), cancelAnimationFrame(this.requestId))
            });
            a(this, "onResize", () => {
                this.quadGL || this.onResize.bind(this), this.quadGL.onResize()
            });
            a(this, "destroy", () => new Promise(t => {
                this.isDestroyed = !0, this.cancelRenderLoop(), this.quadGL.destroy(), this.textures = null, this.canvas = null, this.quadGL = null, t()
            }));
            this.options = t, this.parent = t.parent, this.canvas = t.canvas, this.isCover = t.isCover, this.duration = t.duration, this.interval = t.interval, this.images = t.images, this.effect = t.effect, this.direction = t.direction, this.invert = t.invert, this.blurLevel = t.blurLevel, this.scale = t.scale, this.textures = [], this.uniforms = {}, this.textureResolution = {
                width: 0,
                height: 0
            }, this.progress = 0, this.nextTextureIndex = 1, this.requestId = 0, this.startTime = 0, this.isInitialized = !1, this.shouldRender = !0, this.getShadersSource(), this.quadGL = new r({
                vertexSource: this.vertexSource,
                fragmentSource: this.fragmentSource,
                ...t
            }), this.loadImages()
        }
        loadImages() {
            Promise.all(this.images.map(this.loadImage)).then(t => {
                this.loadedImages = t, this.init()
            })
        }
        loadImage(t) {
            return new Promise((e, s) => {
                const i = new Image;
                i.crossOrigin = "anonymous", i.src = t, i.onload = () => e(i), i.onerror = h => s(h)
            })
        }
        init() {
            this.createTextures(), this.initState(), this.initEvents(), requestAnimationFrame(this.render.bind(this)), this.intervalId = setInterval(this.animate.bind(this), this.interval), this.isInitialized = !0
        }
        getFragmentDiff() {
            let t = null;
            switch (this.effect) {
                case "blobs":
                    t = `
					vec4 currentTexture = texture2D(uCurrentTexture, uv);
					vec4 nextTexture = texture2D(uNextTexture, uv);

					float noise = noise(uv * uScale);
					float progress = mix(-uBlur, 1.0 + uBlur, uProgress);
					float lower = progress - uBlur;
					float higher = progress + uBlur;

					float alpha = smoothstep(lower, higher, noise);

					gl_FragColor = mix(currentTexture, nextTexture, 1.0 - alpha);
				`;
                    break;
                case "circular-mask":
                    t = `
				vec4 currentTexture = texture2D(uCurrentTexture, uv);
					vec4 nextTexture = texture2D(uNextTexture, uv);
					float effect = 0.;

					switch (uDirection) {
						case 0:
							if (uInvert == 1.) {
								effect = uInvert - distance(uv, vec2(0.5));
							} else {
								effect = distance(uv, vec2(0.5));
							}
							break;
						case 1:
							if (uInvert == 1.) {
								effect = cos( distance( uv, vec2(1., .5)  ) );
							} else {
								effect = sin( distance( uv, vec2(1., .5)  ) );
							}
							break;
						case 2:
							if (uInvert == 1.) {
								effect = cos( distance( uv, vec2(.0, .5)  ) );
							} else {
								effect = sin( distance( uv, vec2(.0, .5)  ) );
							}
							break;
						case 3:
							if (uInvert == 1.) {
								effect = cos( distance( uv, vec2(.5, .0)  ) );
							} else {
								effect = sin( distance( uv, vec2(.5, .0)  ) );
							}
							break;
						case 4:
							if (uInvert == 1.) {
								effect = cos( distance( uv, vec2(.5, 1.)  ) );
							} else {
								effect = sin( distance( uv, vec2(.5, 1.)  ) );
							}
							break;
						case 5:
							if (uInvert == 1.) {
								effect = cos( distance( uv, vec2(1.,0.)  ) );
							} else {
								effect = sin( distance( uv, vec2(1.,0.)  ) );
							}
							break;
						case 6:
							if (uInvert == 1.) {
								effect = cos( distance( uv, vec2(0.)  ) );
							} else {
								effect = sin( distance( uv, vec2(0.)  ) );
							}
							break;
						case 7:
							if (uInvert == 1.) {
								effect = cos( distance( uv, vec2(0.,1.)  ) );
							} else {
								effect = sin( distance( uv, vec2(0.,1.)  ) );
							}
							break;
						case 8:
							if (uInvert == 1.) {
								effect = cos( distance( uv, vec2(1.)  ) );
							} else {
								effect = sin( distance( uv, vec2(1.)  ) );
							}
							break;
					}

					float progress = step(effect, uProgress);
					gl_FragColor = mix(currentTexture, nextTexture, progress );
				`;
                    break;
                case "color-mix":
                    t = `
					vec4 currentTexture = texture2D(uCurrentTexture, uv);
					vec4 nextTexture = texture2D(uNextTexture, uv);

					float colorDistance = distance(currentTexture, nextTexture) * .5;
					float progressStep = step(colorDistance, uProgress);

					gl_FragColor = mix(
						mix(currentTexture, nextTexture, progressStep),
						nextTexture,
						uProgress);
				`;
                    break;
                case "blend-wave":
                default:
                    t = `
					float rise = 1.;
					switch (uDirection) {
						case 0:
							vec2 center = vec2(0.5);
							float width = 0.35;
							float radius = 0.9;
							float dist = distance(center, uv);
							float circle = 1.0 - smoothstep(-width, 0.0, radius * dist - uProgress * ( 1.0 + width));
							rise = pow(abs(circle), 1.0);
							break;

						case 1:
							rise = pow(abs(smoothstep(0., 1., ( uProgress * 2.0 + uv.x - 0.5))), 10.);
							break;
						case 2:
							rise = pow(abs(smoothstep(0., 1., ( uProgress * 2.0 - uv.x + 0.5))), 10.);
							break;
						case 3:
							rise = pow(abs(smoothstep(0., 1., ( uProgress * 2.0 - uv.y + 0.5))), 10.);
							break;
						case 4:
							rise = pow(abs(smoothstep(0., 1., ( uProgress * 2.0 + uv.y - 0.5))), 10.);
							break;
						case 5:
							rise = pow(abs(smoothstep(0., 1., ( uProgress * 2.5 + (uv.x - uv.y - .5)))), 10.);
							break;
						case 6:
							rise = pow(abs(smoothstep(0., 1., ( uProgress * 2.5 - (uv.y + uv.x - .5)))), 10.);
							break;
						case 7:
							rise = pow(abs(smoothstep(0., 1., ( uProgress * 2.5 + (uv.y - uv.x - .5)))), 10.);
							break;
						case 8:
							rise = pow(abs(smoothstep(0., 1., ( uProgress * 2.5 + (uv.y + uv.x - 1.5)))), 10.);
							break;
					}

					vec4 currentTexture = texture2D(uCurrentTexture, ( uv - 0.5) * (1.0 - rise) + 0.5);
					vec4 nextTexture = texture2D(uNextTexture, ( uv - 0.5 ) * rise + 0.5);

					gl_FragColor = mix(currentTexture, nextTexture, rise);
				`;
                    break
            }
            return t
        }
        getShadersSource() {
            this.vertexSource = `#version 300 es

		#define attribute in
		#define varying out

		attribute vec4 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			gl_Position = position;

			vUv = uv;
		}
	  `, this.fragmentSource = `#version 300 es
	  #define varying in
	  #define texture2D texture
	  precision highp float;

	  out highp vec4 pc_fragColor;
	  #define gl_FragColor pc_fragColor

	  varying vec2 vUv;

	  uniform sampler2D uCurrentTexture;
	  uniform sampler2D uNextTexture;
	  uniform vec2 uResolution;
	  uniform vec2 uTextureResolution;
	  uniform float uProgress;
	  uniform float uCover;
	  uniform int uDirection;
	  uniform float uInvert;
	  uniform float uBlur;
	  uniform float uScale;

	  vec2 backgroundContain(vec2 uv, vec2 resolution, vec2 texResolution) {
		  float tAspect = texResolution.x / texResolution.y;
		  float pAspect = resolution.x / resolution.y;
		  float pwidth = resolution.x;
		  float pheight = resolution.y;

		  float width = 0.0;
		  float height = 0.0;
		  if(tAspect > pAspect) {
			  height = pheight;
			  width = height * tAspect;
		  } else {
			  width = pwidth;
			  height = width / tAspect;
		  }
		  float x = (pwidth - width) / 2.0;
		  float y = (pheight - height) / 2.0;
		  vec2 nUv = uv;
		  nUv -= vec2(x, y) / resolution;
		  nUv /= vec2(width, height) / resolution;
		  return nUv;
	  }

	  vec2 backgroundCover(vec2 uv, vec2 resolution, vec2 texResolution) {
		  vec2 s = resolution; // Screen
		  vec2 i = texResolution; // Image
		  float rs = s.x / s.y;
		  float ri = i.x / i.y;
		  vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
		  vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
		  return uv * s / new + offset;
	  }

	  float rand(vec2 n) {
		  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
	  }

	  float noise(vec2 p){
		  vec2 ip = floor(p);
		  vec2 u = fract(p);
		  u = u*u*(3.0-2.0*u);

		  float res = mix(
			  mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
			  mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
		  return res*res;
	  }

	  void main() {

		  vec2 uv = vUv;
		  if (uCover == 1.) {
			  uv = backgroundCover(vUv, uResolution, uTextureResolution);
		  } else {
			  uv = backgroundContain(vUv, uResolution, uTextureResolution);
		  }

		  ${this.getFragmentDiff()}
	  }
	`
        }
        createTextures() {
            var t, e;
            this.textures = this.loadedImages.map(this.quadGL.createTexture), this.textureResolution.width = (t = this.loadedImages[0]) == null ? void 0 : t.width, this.textureResolution.height = (e = this.loadedImages[0]) == null ? void 0 : e.height
        }
        initState() {
            this.currentTexture = this.textures[0], this.nextTexture = this.textures[1], this.setActiveTextures(), this.setUniforms()
        }
        setActiveTextures() {
            this.quadGL.gl.activeTexture(this.quadGL.gl.TEXTURE0), this.quadGL.gl.bindTexture(this.quadGL.gl.TEXTURE_2D, this.currentTexture), this.quadGL.gl.activeTexture(this.quadGL.gl.TEXTURE1), this.quadGL.gl.bindTexture(this.quadGL.gl.TEXTURE_2D, this.nextTexture)
        }
        setUniforms() {
            switch (this.uniforms.uTextureResolution = this.quadGL.createUniform("uTextureResolution", "uniform2f", [this.textureResolution.width, this.textureResolution.height]), this.uniforms.uProgress = this.quadGL.createUniform("uProgress", "uniform1f", this.progress, !0), this.uniforms.uCover = this.quadGL.createUniform("uCover", "uniform1f", this.isCover), this.uniforms.uTexture1 = this.quadGL.createUniform("uCurrentTexture", "uniform1i", 0), this.uniforms.uTexture2 = this.quadGL.createUniform("uNextTexture", "uniform1i", 1), this.quadGL.addUniform(this.uniforms.uTextureResolution), this.quadGL.addUniform(this.uniforms.uProgress), this.quadGL.addUniform(this.uniforms.uCover), this.quadGL.addUniform(this.uniforms.uTexture1), this.quadGL.addUniform(this.uniforms.uTexture2), this.effect) {
                case "blend-wave":
                    this.uniforms.uDirection = this.quadGL.createUniform("uDirection", "uniform1i", this.direction), this.quadGL.addUniform(this.uniforms.uDirection);
                    break;
                case "blobs":
                    this.uniforms.uBlur = this.quadGL.createUniform("uBlur", "uniform1f", this.blurLevel), this.uniforms.uScale = this.quadGL.createUniform("uScale", "uniform1f", this.scale), this.quadGL.addUniform(this.uniforms.uScale), this.quadGL.addUniform(this.uniforms.uBlur);
                    break;
                case "circular-mask":
                    this.uniforms.uDirection = this.quadGL.createUniform("uDirection", "uniform1i", this.direction), this.uniforms.uInvert = this.quadGL.createUniform("uInvert", "uniform1f", this.invert), this.quadGL.addUniform(this.uniforms.uDirection), this.quadGL.addUniform(this.uniforms.uInvert);
                    break
            }
        }
        outSine(t, e, s, i) {
            return s * Math.sin(t / i * (Math.PI / 2)) + e
        }
        initEvents() {
            this.quadGL.on("intersection", t => {
                this.shouldRender = t, this.shouldRender && !this.isInitialized && this.init()
            })
        }
        render() {
            requestAnimationFrame(this.render.bind(this)), !this.isDestroyed && (!this.shouldRender || (this.quadGL.preUpdate(), this.uniforms.uProgress && (this.uniforms.uProgress.value = this.progress, this.quadGL.updateUniform(this.uniforms.uProgress)), this.quadGL.update(), this.quadGL.draw()))
        }
        cancelRenderLoop() {
            clearInterval(this.intervalId), cancelAnimationFrame(this.requestId)
        }
    }
    return o
});